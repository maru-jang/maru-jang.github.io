---
layout: post
title:  "[디지털영상처리]Intensity Transformations and Spatial Filtering - 1"
subtitle:   "Digital Image Processing, Intensity Transformations"
categories: CV
tags: 영상처리
---
<blockquote>
<p><span>본 글은 디지털영상처리를 공부한 기록입니다.</span><br /><span>출처 : </span><span>대학공개강의 전남대학교 홍성훈 교수 디지털영상처리 강의 <span style="color: #666666;">(</span><a href="http://www.kocw.net/home/cview.do?mty=p&amp;kemId=320576">www.kocw.net/home/cview.do?mty=p&amp;kemId=320576)</a><br /><span style="color: #666666;">Digital Image Processing, 3rd Edition, Gonzalez and Wood, Pearson (2010)<br /></span></span><span style="color: #333333; letter-spacing: 0px;"></span></p>
</blockquote>
<div data-ke-type="moreLess" data-text-more="더보기" data-text-less="닫기"><a class="btn-toggle-moreless">더보기</a>
<div class="moreless-content">
<p>※용어 설명</p>
<p>Restoration 원본에 가깝게</p>
<p>Enhancement 사람 눈에만 잘 보이게</p>
</div>
</div>
<h2 data-ke-size="size26">Background</h2>
<p>[##_Image|kage@lOM9t/btq16RUkl1x/k1cw4mc8ILG7QLishyL6t0/img.png|alignCenter|data-origin-width="0" data-origin-height="0" data-ke-mobilestyle="widthContent"|||_##]</p>
<p style="text-align: center;">f(x,y) :&nbsp; input image</p>
<p style="text-align: center;">g(x,y) : output image</p>
<p style="text-align: center;">T[&nbsp; ] : operator (변환)</p>
<p>&nbsp;</p>
<p>[##_Image|kage@ozw8Q/btq1ZEW0mww/fZKiRtSuI9lALx6NxxG6NK/img.png|alignCenter|data-origin-width="0" data-origin-height="0" data-ke-mobilestyle="widthContent"|Intensity transformation||_##]</p>
<p>왼쪽과 같은 경우는 Contrast-stretching으로 input image의 k 밝기 이하는 어둡게 k 밝기 이상은 밝게 만들어서 원래 영상보다 높은 Contrast(대비)를 갖는 영상을 만들게 되는것이다.</p>
<p>오른쪽의 경우에는 k를 기준으로 이진으로 매핑 하는 것을 Thresholding function이라 한다.</p>
<p>매우 단순하고 강력한 처리를 행한다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">이로써 기본적인 밝기 변환에 대해서 알아보았다.</p>
<h2 data-ke-size="size26">Basic Intensity Transformation Functions</h2>
<p>[##_Image|kage@z5XPe/btq16r2Fvnn/3CZSmfXEDXTFT4loKpg3H1/img.png|alignCenter|data-origin-width="0" data-origin-height="0" width="409" height="NaN" data-ke-mobilestyle="widthContent"|기본적 밝기 변환 함수들||_##]</p>
<p>위 사진은 기본적인 밝기 변환 함수들을 나타내는데, log 변환은 어두운 레벨에 분포된 픽셀들을 넓은 범위의 밝기로 표현하여 어두운 쪽을 잘보이게 하는 변환이며, 역 log 변환은 그와 반대로 밝은 쪽을 잘보이게 하는 변환이다.</p>
<h4 data-ke-size="size20">Negative Trasformations</h4>
<p>[##_Image|kage@bHkXsD/btq14Y0WyDQ/H5Jmkd9NjXR9EgLoPcwhKk/img.png|alignCenter|data-origin-width="0" data-origin-height="0" data-ke-mobilestyle="widthContent"|||_##]</p>
<p style="text-align: center;">r : input</p>
<p style="text-align: center;">s : output</p>
<p>[##_Image|kage@bJEttR/btq16zsLC9B/MI0KXr0Cp9AjrbtqdaMwX1/img.png|alignCenter|data-origin-width="0" data-origin-height="0" width="504" height="NaN" data-ke-mobilestyle="widthContent"|||_##]</p>
<p>위와 같은 방식으로 밝기 레벨을 반전시킴으로써 영상의 어두운 영역에 놓여있는 흰색이나 그레이 디테일을 개선 시키는 데 적합하다.</p>
<p>위의 가슴 X-ray 사진의 예시와 같이 Negative Transform을 통해 조직을 분석하는 것이 더욱 쉬워진다.</p>
<h4 data-ke-size="size20">Log Transformations</h4>
<p>[##_Image|kage@bHEoD8/btq1XTtl1TP/Gv4meIf27HKJyA3pUWnSr0/img.png|alignCenter|data-origin-width="0" data-origin-height="0" width="524" height="NaN" data-ke-mobilestyle="widthContent"|||_##]</p>
<p>앞선 Log 변환의 설명을 잘 보여주는 예시이다.</p>
<p>고주파쪽의 에너지가 적어서 어두운 부분이 잘 안보이는 현상이 나타난다.</p>
<p>따라서 어두운쪽을 Stretching 시켜야 한다.</p>
<h4 data-ke-size="size20">Power-Law(Gamma) Transformations</h4>
<p>[##_Image|kage@cIJ0yF/btq1ZFBCkS3/3XpFmArYUbHq2oiM7CQ3t1/img.png|alignCenter|data-origin-width="0" data-origin-height="0" width="424" height="NaN" data-ke-mobilestyle="widthContent"|||_##]</p>
<p>input image에 gamma 제곱을 하는 변환으로, Gamma가 1보다 커지면 밝은 쪽이 Stretching되어 잘보이게 되어지게 된다.</p>
<p>[##_Image|kage@bHN1Te/btq12l98b0Q/jDl2lSYDOS93ihkzsGRNP0/img.png|alignCenter|data-origin-width="0" data-origin-height="0" width="527" height="NaN" data-ke-mobilestyle="widthContent"|||_##]</p>
<p>이에 대한 예시로 어떠한 화면이 TV모니터, 스크린 상으로 보게 된다면 퇴색해 보이거나, 어두워 보일 수 있다.</p>
<p>이 때문에 적절한 Gamma 보정이 필요하다.</p>
<p>Gamma 보정을 거쳐 Original Image와 비슷하게 보일 수 있다. <span style="color: #333333;">이렇게 Gamma 보정은&nbsp;</span><span style="color: #333333;">Contrast Enhancment에 유용하다.</span></p>
<p>&nbsp;</p>
<p>추가로 Gamma보정은 적, 녹, 청의 비도 바뀌기 때문에 컬러를 정확하게 재현하기 위해서는 Gamma 보정에 주의가 필요하다.</p>
<h4 data-ke-size="size20">Piecewise-Linear Transformations</h4>
<p>[##_Image|kage@dgGFz8/btq16Aee0Qc/4h5rov5nOpbx3QQE1iisFk/img.png|alignCenter|data-origin-width="0" data-origin-height="0" width="527" height="NaN" data-ke-mobilestyle="widthContent"|||_##]</p>
<p>그림(a)에서 r1~r2의 input 값을 더욱 잘 보이게 하는 Stretching을 하는 결과 (b)가 (c)와 같이 보이게 된다.</p>
<p>(d)는 thresholding 처리한 것으로 극단적인 예이다.</p>
<p>&nbsp;</p>
<p>이렇게 구간을 정하여 선형으로 변환하는 경우도 있다.</p>
<p>[##_Image|kage@DduDk/btq11M08xUw/GSmnYATnSgXn6H3wKdJWeK/img.png|alignCenter|data-origin-width="0" data-origin-height="0" width="452" height="NaN" data-ke-mobilestyle="widthContent"|||_##]</p>
<p>왼쪽 그림과 같은 구간 변환은 AB구간만 남기고 안보이게 하는 변환.</p>
<p>오른쪽은 원본 이미지와 같게 하되, AB구간을더욱 잘보이게 하는 변환이다.</p>
<p>아래는 순서대로 원본, 왼쪽과 같은 변환, 오른쪽과 같은 변환을 나타낸 그림이다.</p>
<p>[##_Image|kage@bN0VDH/btq16yOgohY/e352vu45ogkpkWqZq2lppK/img.png|alignCenter|data-origin-width="0" data-origin-height="0" width="498" height="NaN" data-ke-mobilestyle="widthContent"|||_##]</p>
<h4 data-ke-size="size20">Bit-Plane Slicing</h4>
<p>[##_Image|kage@tNv4Z/btq12651uol/NNKDpv0UjWLko5X68ViII0/img.png|alignCenter|data-origin-width="0" data-origin-height="0" width="381" height="NaN" data-ke-mobilestyle="widthContent"|||_##]</p>
<p>8bit 영상은 1비트 평면 8개로 구성되어 있다.</p>
<p>필요한 Bit-Plane의 Scale만 뽑아서 처리할 수 있다.</p>
<p>[##_Image|kage@vXPrz/btq11yPuNtX/8v6muymEKRiWj8clQook01/img.png|alignCenter|data-origin-width="0" data-origin-height="0" width="626" height="NaN" data-ke-mobilestyle="widthContent"|(좌&gt;우) 원본, 0(LS), 1, 2, 3, 4, 5, 6, 7(MS)||_##][##_Image|kage@3Gcju/btq11AfvsST/yAcjJEl5chMapWxy0QXEOk/img.png|alignCenter|data-origin-width="0" data-origin-height="0" width="236" height="NaN" data-ke-mobilestyle="widthContent"|8, 7 Bit-Plane||_##]</p>
<p>&nbsp;</p>
<p>그림에서 볼 수 있듯이 중요도는 MSB에 가까울수록 중요함을 확인 할 수 있고, 8, 7 Bit Plane만 있어도 원본과 비슷함을 알 수 있다.</p>
<p>하지만 LSB에 가까운 Plane도 영상이 단조로워 보이지 않기 위해서 필요한 Bit-Plane들이다.</p>
<h2 data-ke-size="size26">Histogram Processing</h2>
<p>&nbsp;</p>
<p>[##_Image|kage@bxLhP5/btq16QnG9pH/pUPKZlwjWI4SKh0vODPDDK/img.png|alignCenter|data-origin-width="0" data-origin-height="0" width="591" height="NaN" data-ke-mobilestyle="widthContent"|||_##]</p>
<p>영상의 밝기 값들의 빈도 수를 카운트해서 이산 함수로 나타낸 것이 히스토그램이다.</p>
<p>이를 전체 화소수로 나누어서 정규화를 시킬 수 있다. (PDF, 확률밀도함수)</p>
<p>&nbsp;</p>
<p>이러한 과정을 직접 코딩을 통해 해보도록 하는 시간을 가져보자.</p>
<p>&nbsp;</p>
<p>이러한 히스토그램을 보고 Equalization(평활화) 처리를 함으로써 이미지를 개선시킬 수 있다.</p>
<p>s(output)은 uniform 해야 한다.</p>
<p>[##_Image|kage@XfIme/btq1ZGAAnkQ/hZr4ri1vQjixVLXuLKKzPK/img.png|alignCenter|width="368" height="NaN" data-origin-width="0" data-origin-height="0" data-ke-mobilestyle="widthContent"|위 예시의 히스토그램 누적 분포 함수(CDF)||_##]</p>
<p>&nbsp;</p>
<p>복잡한 계산 과정이 있지만 생략하고 간단하게 설명하자면 Histogram Equalization은 CDF를 가져다가 적절히 맵핑을 한다면 uniform한 Histogram과 함께 개선된 image가 확인됨을 알 수 있다.</p>
<p>1번의 예시로만 설명하자면 모든 화소가 어두운 쪽의 화소에 집중 되어 있고 이것 만을 맵핑시키면 됨을 알 수 있다.</p>
<p>간단히 설명했지만 복잡한 계산 과정이 있으므로 추후 궁금하다면 다시 한번 찾아보자.</p>
<p>&nbsp;</p>
<p>다음 시간에 히스토그램과 Spatial Filtering(공간 필터링)을 이어서 공부해보도록 하자.</p>